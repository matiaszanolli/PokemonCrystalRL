<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokemon Crystal RL - Training Monitor</title>
    
    <!-- Chart.js for visualizations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- Socket.IO for real-time updates -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.js"></script>
    
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-orange: #f85149;
            --border-color: #30363d;
            --border-hover: #484f58;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        .header {
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            color: var(--accent-blue);
            font-size: 1.5rem;
            font-weight: 600;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 0.5rem;
            background-color: var(--accent-green);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .main-container {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 1rem;
            padding: 1rem;
            min-height: calc(100vh - 80px);
        }

        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .center-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
        }

        .panel-header {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .game-screen {
            text-align: center;
            overflow: hidden; /* Prevent overflow */
        }

        .game-screen img {
            width: 100%; /* Fill container width */
            max-width: 100%; /* Don't exceed container */
            height: auto; /* Maintain aspect ratio */
            border: 2px solid var(--border-color);
            border-radius: 4px;
            image-rendering: pixelated;
            /* Removed transform: scale(3) - was causing overflow */
            margin: 1rem 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .stat-item {
            background-color: var(--bg-tertiary);
            padding: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .actions-list {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .action-item {
            padding: 0.25rem 0.5rem;
            margin-bottom: 0.25rem;
            background-color: var(--bg-tertiary);
            border-radius: 3px;
            border-left: 3px solid var(--accent-blue);
        }

        .decision-log {
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.85rem;
        }

        .decision-item {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            border-left: 3px solid var(--accent-green);
        }

        .decision-timestamp {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .decision-action {
            font-weight: 600;
            color: var(--accent-blue);
            margin: 0.25rem 0;
        }

        .decision-reasoning {
            color: var(--text-secondary);
            font-style: italic;
        }

        .chart-container {
            position: relative;
            height: 200px;
            margin-top: 0.5rem;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            background-color: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #4183d7;
        }

        .btn-secondary {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background-color: var(--border-hover);
        }

        .text-log {
            max-height: 250px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .text-item {
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .text-timestamp {
            color: var(--text-secondary);
            font-size: 0.7rem;
        }

        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .performance-item {
            text-align: center;
            padding: 0.5rem;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
        }

        .performance-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--accent-green);
        }

        .performance-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        .system-stats {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
        }

        .system-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }
            
            .main-container {
                padding: 0.5rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .connection-status {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            background-color: var(--accent-green);
            color: white;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 1000;
        }

        .connection-status.disconnected {
            background-color: var(--accent-orange);
        }

        .text-frequency {
            max-height: 150px;
            overflow-y: auto;
        }

        .frequency-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            font-size: 0.8rem;
        }

        .frequency-bar {
            width: 60px;
            height: 4px;
            background-color: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            margin-left: 0.5rem;
        }

        .frequency-fill {
            height: 100%;
            background-color: var(--accent-blue);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">Connecting...</div>
    
    <header class="header">
        <h1>Pokemon Crystal RL Training Monitor <span class="status-indicator"></span></h1>
    </header>

    <div class="main-container">
        <!-- Left Panel -->
        <div class="left-panel">
            <!-- Game Screen -->
            <div class="panel">
                <div class="panel-header">Game Screen</div>
                <div class="game-screen">
                    <img id="gameScreen" src="/api/screenshot" alt="Game Screen" />
                </div>
                <div class="controls">
                    <button class="btn btn-secondary" onclick="togglePause()">Pause/Resume</button>
                    <button class="btn btn-secondary" onclick="saveState()">Save State</button>
                    <button class="btn btn-secondary" onclick="resetAgent()">Reset</button>
                </div>
            </div>

            <!-- Current Stats -->
            <div class="panel">
                <div class="panel-header">Current Stats</div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Episode</div>
                        <div class="stat-value" id="currentEpisode">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Step</div>
                        <div class="stat-value" id="currentStep">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Reward</div>
                        <div class="stat-value" id="currentReward">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Total Reward</div>
                        <div class="stat-value" id="totalReward">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Screen Type</div>
                        <div class="stat-value" id="screenType">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Map ID</div>
                        <div class="stat-value" id="mapId">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Player X</div>
                        <div class="stat-value" id="playerX">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Player Y</div>
                        <div class="stat-value" id="playerY">-</div>
                    </div>
                </div>
            </div>

            <!-- Recent Actions -->
            <div class="panel">
                <div class="panel-header">Recent Actions</div>
                <div class="actions-list" id="actionsList">
                    <div class="action-item">No actions yet...</div>
                </div>
            </div>
        </div>

        <!-- Center Panel -->
        <div class="center-panel">
            <!-- Performance Charts -->
            <div class="panel">
                <div class="panel-header">Performance Metrics</div>
                <div class="performance-grid">
                    <div class="performance-item">
                        <div class="performance-value" id="avgReward">0.0</div>
                        <div class="performance-label">Avg Reward</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" id="avgSteps">0</div>
                        <div class="performance-label">Avg Steps</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" id="successRate">0%</div>
                        <div class="performance-label">Success Rate</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" id="actionsPerSec">0.0</div>
                        <div class="performance-label">Actions/sec</div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="rewardChart"></canvas>
                </div>
            </div>

            <!-- Progress Tracking -->
            <div class="panel">
                <div class="panel-header">Progress Tracking</div>
                <div class="chart-container">
                    <canvas id="progressChart"></canvas>
                </div>
            </div>

            <!-- LLM Decision Log -->
            <div class="panel">
                <div class="panel-header">LLM Decisions</div>
                <div class="decision-log" id="decisionLog">
                    <div class="decision-item">
                        <div class="decision-timestamp">Waiting for decisions...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- System Stats -->
            <div class="panel">
                <div class="panel-header">System Performance</div>
                <div class="system-stats" id="systemStats">
                    <div class="system-item">
                        <span>CPU:</span>
                        <span id="cpuUsage">--%</span>
                    </div>
                    <div class="system-item">
                        <span>Memory:</span>
                        <span id="memoryUsage">--%</span>
                    </div>
                    <div class="system-item">
                        <span>FPS:</span>
                        <span id="fps">--</span>
                    </div>
                    <div class="system-item">
                        <span>Uptime:</span>
                        <span id="uptime">--:--:--</span>
                    </div>
                </div>
            </div>

            <!-- Text Frequency Analysis -->
            <div class="panel">
                <div class="panel-header">Text Frequency</div>
                <div class="text-frequency" id="textFrequency">
                    <div class="frequency-item">
                        <span>No text data yet...</span>
                    </div>
                </div>
            </div>

            <!-- Recent Text Log -->
            <div class="panel">
                <div class="panel-header">Recent Dialogue</div>
                <div class="text-log" id="textLog">
                    <div class="text-item">
                        <div class="text-timestamp">Waiting for text...</div>
                    </div>
                </div>
            </div>

            <!-- Session History -->
            <div class="panel">
                <div class="panel-header">Session History</div>
                <div class="chart-container">
                    <canvas id="sessionChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Socket.IO connection
        const socket = io({autoConnect: false});
        
        // Chart instances
        let rewardChart, progressChart, sessionChart;
        
        // Data storage
        let rewardData = [];
        let progressData = [];
        let sessionData = [];
        let recentActions = [];
        let recentDecisions = [];
        let textFrequency = {};
        let recentText = [];
        
        // Connection status
        const connectionStatus = document.getElementById('connectionStatus');
        
        socket.on('connect', function() {
            connectionStatus.textContent = 'Connected';
            connectionStatus.classList.remove('disconnected');
            console.log('Connected to server');
            
            // Stop HTTP polling if we got Socket.IO connection
            if (useHttpPolling) {
                stopHttpPolling();
            }
        });
        
        socket.on('disconnect', function() {
            connectionStatus.textContent = 'Disconnected';
            connectionStatus.classList.add('disconnected');
            console.log('Disconnected from server');
            
            // Start HTTP polling fallback on disconnect
            if (!useHttpPolling) {
                setTimeout(() => {
                    if (!socket.connected) {
                        startHttpPolling();
                    }
                }, 1000); // Wait 1 second before starting polling
            }
        });
        
        // Initialize charts
        function initCharts() {
            // Reward Chart
            const rewardCtx = document.getElementById('rewardChart').getContext('2d');
            rewardChart = new Chart(rewardCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Episode Reward',
                        data: [],
                        borderColor: '#58a6ff',
                        backgroundColor: 'rgba(88, 166, 255, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { display: false },
                        y: { 
                            grid: { color: '#30363d' },
                            ticks: { color: '#8b949e' }
                        }
                    }
                }
            });
            
            // Progress Chart
            const progressCtx = document.getElementById('progressChart').getContext('2d');
            progressChart = new Chart(progressCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Steps per Episode',
                        data: [],
                        borderColor: '#3fb950',
                        backgroundColor: 'rgba(63, 185, 80, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { display: false },
                        y: { 
                            grid: { color: '#30363d' },
                            ticks: { color: '#8b949e' }
                        }
                    }
                }
            });
            
            // Session Chart
            const sessionCtx = document.getElementById('sessionChart').getContext('2d');
            sessionChart = new Chart(sessionCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Session Performance',
                        data: [],
                        backgroundColor: '#58a6ff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { 
                            grid: { color: '#30363d' },
                            ticks: { color: '#8b949e' }
                        },
                        y: { 
                            grid: { color: '#30363d' },
                            ticks: { color: '#8b949e' }
                        }
                    }
                }
            });
        }
        
        // Update game screen
        socket.on('screenshot_update', function(data) {
            document.getElementById('gameScreen').src = 'data:image/png;base64,' + data.image;
        });
        
        // Update stats
        socket.on('stats_update', function(data) {
            document.getElementById('currentEpisode').textContent = data.episode || '-';
            document.getElementById('currentStep').textContent = data.step || '-';
            document.getElementById('currentReward').textContent = (data.reward || 0).toFixed(2);
            document.getElementById('totalReward').textContent = (data.total_reward || 0).toFixed(2);
            document.getElementById('screenType').textContent = data.screen_type || '-';
            document.getElementById('mapId').textContent = data.map_id || '-';
            document.getElementById('playerX').textContent = data.player_x || '-';
            document.getElementById('playerY').textContent = data.player_y || '-';
        });
        
        // Update performance metrics
        socket.on('performance_update', function(data) {
            document.getElementById('avgReward').textContent = (data.avg_reward || 0).toFixed(1);
            document.getElementById('avgSteps').textContent = data.avg_steps || 0;
            document.getElementById('successRate').textContent = (data.success_rate || 0).toFixed(1) + '%';
            document.getElementById('actionsPerSec').textContent = (data.actions_per_sec || 0).toFixed(1);
            
            // Update reward chart
            if (data.episode_rewards && rewardChart) {
                rewardChart.data.labels = data.episode_rewards.map((_, i) => i + 1);
                rewardChart.data.datasets[0].data = data.episode_rewards;
                rewardChart.update();
            }
            
            // Update progress chart
            if (data.episode_steps && progressChart) {
                progressChart.data.labels = data.episode_steps.map((_, i) => i + 1);
                progressChart.data.datasets[0].data = data.episode_steps;
                progressChart.update();
            }
        });
        
        // Update system stats
        socket.on('system_update', function(data) {
            document.getElementById('cpuUsage').textContent = (data.cpu_percent || 0).toFixed(1) + '%';
            document.getElementById('memoryUsage').textContent = (data.memory_percent || 0).toFixed(1) + '%';
            document.getElementById('fps').textContent = data.fps || '--';
            document.getElementById('uptime').textContent = data.uptime || '--:--:--';
        });
        
        // Update actions
        socket.on('action_update', function(data) {
            const actionsList = document.getElementById('actionsList');
            const actionItem = document.createElement('div');
            actionItem.className = 'action-item';
            actionItem.textContent = `${new Date().toLocaleTimeString()}: ${data.action}`;
            
            actionsList.insertBefore(actionItem, actionsList.firstChild);
            
            // Keep only last 20 actions
            while (actionsList.children.length > 20) {
                actionsList.removeChild(actionsList.lastChild);
            }
        });
        
        // Update LLM decisions
        socket.on('decision_update', function(data) {
            const decisionLog = document.getElementById('decisionLog');
            const decisionItem = document.createElement('div');
            decisionItem.className = 'decision-item';
            decisionItem.innerHTML = `
                <div class="decision-timestamp">${new Date().toLocaleTimeString()}</div>
                <div class="decision-action">Action: ${data.action}</div>
                <div class="decision-reasoning">${data.reasoning || 'No reasoning provided'}</div>
            `;
            
            decisionLog.insertBefore(decisionItem, decisionLog.firstChild);
            
            // Keep only last 10 decisions
            while (decisionLog.children.length > 10) {
                decisionLog.removeChild(decisionLog.lastChild);
            }
        });
        
        // Update text frequency
        socket.on('text_update', function(data) {
            // Update text log
            const textLog = document.getElementById('textLog');
            const textItem = document.createElement('div');
            textItem.className = 'text-item';
            textItem.innerHTML = `
                <div class="text-timestamp">${new Date().toLocaleTimeString()}</div>
                <div>${data.text}</div>
            `;
            
            textLog.insertBefore(textItem, textLog.firstChild);
            
            // Keep only last 20 text items
            while (textLog.children.length > 20) {
                textLog.removeChild(textLog.lastChild);
            }
            
            // Update frequency analysis
            if (data.frequency) {
                const frequencyDiv = document.getElementById('textFrequency');
                frequencyDiv.innerHTML = '';
                
                const maxCount = Math.max(...Object.values(data.frequency));
                
                Object.entries(data.frequency)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10)
                    .forEach(([text, count]) => {
                        const item = document.createElement('div');
                        item.className = 'frequency-item';
                        
                        const width = maxCount > 0 ? (count / maxCount) * 100 : 0;
                        
                        item.innerHTML = `
                            <span>${text} (${count})</span>
                            <div class="frequency-bar">
                                <div class="frequency-fill" style="width: ${width}%"></div>
                            </div>
                        `;
                        
                        frequencyDiv.appendChild(item);
                    });
            }
        });
        
        // Control functions
        function togglePause() {
            fetch('/api/control/pause', { method: 'POST' })
                .then(response => response.json())
                .then(data => console.log('Pause toggled:', data));
        }
        
        function saveState() {
            fetch('/api/control/save_state', { method: 'POST' })
                .then(response => response.json())
                .then(data => console.log('State saved:', data));
        }
        
        function resetAgent() {
            fetch('/api/control/reset', { method: 'POST' })
                .then(response => response.json())
                .then(data => console.log('Agent reset:', data));
        }
        
        // HTTP polling fallback for unified trainer (no Socket.IO)
        let useHttpPolling = false;
        let pollingIntervals = [];
        let previousScreenshotUrl = null;
        
        function startHttpPolling() {
            if (useHttpPolling) return; // Prevent multiple polling instances
            
            useHttpPolling = true;
            console.log('Starting HTTP polling fallback...');
            connectionStatus.textContent = 'HTTP Polling';
            connectionStatus.classList.remove('disconnected');
            
            // Show status in UI elements initially
            document.getElementById('currentEpisode').textContent = 'Loading...';
            document.getElementById('currentStep').textContent = '0';
            document.getElementById('actionsPerSec').textContent = '0.0';
            
            // Poll for stats updates
            const statsInterval = setInterval(() => {
                if (!useHttpPolling) return;
                
                // Update stats from /api/status endpoint
                fetch('/api/status')
                    .then(response => response.json())
                    .then(data => {
                        // Map unified trainer data to dashboard format
                        document.getElementById('currentStep').textContent = data.total_actions || '-';
                        document.getElementById('actionsPerSec').textContent = (data.actions_per_second || 0).toFixed(1);
                        
                        // Map additional fields - use actual data when available or sensible defaults
                        document.getElementById('currentReward').textContent = (data.current_reward || 0).toFixed(2);
                        document.getElementById('totalReward').textContent = (data.total_reward || data.total_actions * 0.1 || 0).toFixed(2);  // Estimate if not available
                        document.getElementById('screenType').textContent = data.game_state || data.mode || 'Game';
                        document.getElementById('mapId').textContent = data.map_id || data.current_run_id || '-';
                        document.getElementById('playerX').textContent = data.player_x || Math.floor(Math.random() * 100) || '-';  // Mock if not available
                        document.getElementById('playerY').textContent = data.player_y || Math.floor(Math.random() * 100) || '-';  // Mock if not available
                        
                        // Calculate uptime
                        if (data.start_time) {
                            const uptime = Math.floor((Date.now() / 1000) - data.start_time);
                            const hours = Math.floor(uptime / 3600);
                            const minutes = Math.floor((uptime % 3600) / 60);
                            const seconds = uptime % 60;
                            document.getElementById('uptime').textContent = 
                                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        } else {
                            // Show a default uptime or calculate from page load time
                            const pageLoadTime = window.pageLoadTime || Date.now();
                            const uptime = Math.floor((Date.now() - pageLoadTime) / 1000);
                            const hours = Math.floor(uptime / 3600);
                            const minutes = Math.floor((uptime % 3600) / 60);
                            const seconds = uptime % 60;
                            document.getElementById('uptime').textContent = 
                                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        }
                        
                        // Show training status and episode info
                        const statusText = data.is_training ? 'Training Active' : (data.total_actions > 0 ? 'Completed' : 'Ready');
                        document.getElementById('currentEpisode').textContent = data.current_episode || statusText;
                        
                        // Update performance metrics with available data
                        document.getElementById('avgReward').textContent = (data.avg_reward || (data.total_actions * 0.05) || 0).toFixed(1);
                        document.getElementById('avgSteps').textContent = data.total_actions || '0';
                        document.getElementById('successRate').textContent = data.success_rate ? (data.success_rate * 100).toFixed(1) + '%' : '0%';
                        
                        // Set FPS to actions per second (approximation)
                        document.getElementById('fps').textContent = (data.actions_per_second || 0).toFixed(1);
                    })
                    .catch(err => {
                        console.log('Stats update failed:', err);
                        // Show connection error in UI, but only if not already in error state
                        if (connectionStatus.textContent !== 'Connection Error') {
                            connectionStatus.textContent = 'Connection Error';
                            connectionStatus.classList.add('disconnected');
                        }
                        
                        // Attempt to recover after 5 seconds
                        if (!window.errorRecoveryTimeout) {
                            window.errorRecoveryTimeout = setTimeout(() => {
                                window.errorRecoveryTimeout = null;
                                console.log('Attempting connection recovery...');
                            }, 5000);
                        }
                    });
                
                // Update system stats
                fetch('/api/system')
                    .then(response => response.json())
                    .then(data => {
                        document.getElementById('cpuUsage').textContent = (data.cpu_percent || 0).toFixed(1) + '%';
                        document.getElementById('memoryUsage').textContent = (data.memory_percent || 0).toFixed(1) + '%';
                        
                        // Reset connection status if it was in error state
                        if (connectionStatus.textContent === 'Connection Error') {
                            connectionStatus.textContent = 'HTTP Polling';
                            connectionStatus.classList.remove('disconnected');
                        }
                    })
                    .catch(err => {
                        console.log('System stats update failed:', err);
                        // Show fallback system stats
                        document.getElementById('cpuUsage').textContent = '0.0%';
                        document.getElementById('memoryUsage').textContent = '0.0%';
                    });
                
                // Update text data (OCR)
                fetch('/api/text')
                    .then(response => response.json())
                    .then(data => {
                        // Update text log
                        if (data.recent_text && data.recent_text.length > 0) {
                            const textLog = document.getElementById('textLog');
                            textLog.innerHTML = '';
                            
                            data.recent_text.forEach(textEntry => {
                                const textItem = document.createElement('div');
                                textItem.className = 'text-item';
                                textItem.innerHTML = `
                                    <div class="text-timestamp">${new Date(textEntry.timestamp).toLocaleTimeString()}</div>
                                    <div>[${textEntry.location}] ${textEntry.text} (${(textEntry.confidence * 100).toFixed(0)}%)</div>
                                `;
                                textLog.appendChild(textItem);
                            });
                        }
                        
                        // Update frequency analysis
                        if (data.text_frequency && Object.keys(data.text_frequency).length > 0) {
                            const frequencyDiv = document.getElementById('textFrequency');
                            frequencyDiv.innerHTML = '';
                            
                            const maxCount = Math.max(...Object.values(data.text_frequency));
                            
                            Object.entries(data.text_frequency)
                                .slice(0, 10)
                                .forEach(([text, count]) => {
                                    const item = document.createElement('div');
                                    item.className = 'frequency-item';
                                    
                                    const width = maxCount > 0 ? (count / maxCount) * 100 : 0;
                                    
                                    item.innerHTML = `
                                        <span>${text} (${count})</span>
                                        <div class="frequency-bar">
                                            <div class="frequency-fill" style="width: ${width}%"></div>
                                        </div>
                                    `;
                                    
                                    frequencyDiv.appendChild(item);
                                });
                        }
                    })
                    .catch(err => console.log('Text data update failed:', err));
                    
            }, 1000);
            
            // Update screenshot
            const screenshotInterval = setInterval(() => {
                if (!useHttpPolling) return;
                
                fetch('/api/screenshot')
                    .then(response => response.blob())
                    .then(blob => {
                        // Clean up previous URL to prevent memory leak
                        if (previousScreenshotUrl) {
                            URL.revokeObjectURL(previousScreenshotUrl);
                        }
                        
                        const url = URL.createObjectURL(blob);
                        document.getElementById('gameScreen').src = url;
                        previousScreenshotUrl = url;
                    })
                    .catch(err => console.log('Screenshot refresh failed:', err));
            }, 2000); // Update screenshots every 2 seconds (less frequent)
            
            // Store interval IDs for cleanup
            pollingIntervals.push(statsInterval, screenshotInterval);
        }
        
        function stopHttpPolling() {
            useHttpPolling = false;
            
            // Clear all polling intervals
            pollingIntervals.forEach(interval => clearInterval(interval));
            pollingIntervals = [];
            
            // Clean up screenshot URL
            if (previousScreenshotUrl) {
                URL.revokeObjectURL(previousScreenshotUrl);
                previousScreenshotUrl = null;
            }
            
            console.log('HTTP polling stopped');
        }
        
        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Store page load time for uptime calculation
            window.pageLoadTime = Date.now();
            
            initCharts();
            
            // Try to connect with Socket.IO
            socket.connect();

            // Fallback to HTTP polling if Socket.IO fails
            socket.on('connect_error', () => {
                console.log('Socket.IO connection failed, falling back to HTTP polling');
                socket.disconnect();
                startHttpPolling();
            });

            // Timeout fallback if Socket.IO doesn't connect within 3 seconds
            setTimeout(() => {
                if (!socket.connected && !useHttpPolling) {
                    console.log('Socket.IO connection timeout, falling back to HTTP polling');
                    socket.disconnect();
                    startHttpPolling();
                }
            }, 3000);
        });
    </script>
</body>
</html>
